import ast
import numpy
from collections.abc import Sequence
from mapFolding import FREAKOUT as FREAKOUT, ParametersNumba as ParametersNumba, Z0Z_getDatatypeModuleScalar as Z0Z_getDatatypeModuleScalar, Z0Z_getDecoratorCallable as Z0Z_getDecoratorCallable, Z0Z_setDatatypeModuleScalar as Z0Z_setDatatypeModuleScalar, Z0Z_setDecoratorCallable as Z0Z_setDecoratorCallable, getFilenameFoldsTotal as getFilenameFoldsTotal, getPathFilenameFoldsTotal as getPathFilenameFoldsTotal, getPathJobRootDEFAULT as getPathJobRootDEFAULT, parametersNumbaDEFAULT as parametersNumbaDEFAULT
from mapFolding.someAssemblyRequired import NodeReplacer as NodeReplacer, Then as Then, UniversalImportTracker as UniversalImportTracker, decorateCallableWithNumba as decorateCallableWithNumba, ifThis as ifThis, makeStateJob as makeStateJob, thisIsNumbaDotJit as thisIsNumbaDotJit
from os import PathLike
from pathlib import Path
from types import ModuleType
from typing import Any

def Z0Z_gamma(FunctionDefTarget: ast.FunctionDef, astAssignee: ast.Name, statement: ast.Assign | ast.stmt, identifier: str, arrayTarget: numpy.ndarray[tuple[int, ...], numpy.dtype[numpy.integer[Any]]], allImports: UniversalImportTracker) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def insertArrayIn_body(FunctionDefTarget: ast.FunctionDef, identifier: str, arrayTarget: numpy.ndarray[tuple[int, ...], numpy.dtype[numpy.integer[Any]]], allImports: UniversalImportTracker, unrollSlices: int | None = None) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def findAndReplaceTrackArrayIn_body(FunctionDefTarget: ast.FunctionDef, identifier: str, arrayTarget: numpy.ndarray[tuple[int, ...], numpy.dtype[numpy.integer[Any]]], allImports: UniversalImportTracker) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def findAndReplaceArraySubscriptIn_body(FunctionDefTarget: ast.FunctionDef, identifier: str, arrayTarget: numpy.ndarray[tuple[int, ...], numpy.dtype[numpy.integer[Any]]], allImports: UniversalImportTracker) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def removeAssignmentFrom_body(FunctionDefTarget: ast.FunctionDef, identifier: str) -> ast.FunctionDef: ...
def findAndReplaceAnnAssignIn_body(FunctionDefTarget: ast.FunctionDef, allImports: UniversalImportTracker) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def findThingyReplaceWithConstantIn_body(FunctionDefTarget: ast.FunctionDef, object: str, value: int) -> ast.FunctionDef: ...
def findAstNameReplaceWithConstantIn_body(FunctionDefTarget: ast.FunctionDef, name: str, value: int) -> ast.FunctionDef: ...
def insertReturnStatementIn_body(FunctionDefTarget: ast.FunctionDef, arrayTarget: numpy.ndarray[tuple[int, ...], numpy.dtype[numpy.integer[Any]]], allImports: UniversalImportTracker) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def findAndReplaceWhileLoopIn_body(FunctionDefTarget: ast.FunctionDef, iteratorName: str, iterationsTotal: int) -> ast.FunctionDef: ...
def makeLauncherTqdmJobNumba(callableTarget: str, pathFilenameFoldsTotal: Path, totalEstimated: int, leavesTotal: int) -> ast.Module: ...
def makeLauncherBasicJobNumba(callableTarget: str, pathFilenameFoldsTotal: Path) -> ast.Module: ...
def doUnrollCountGaps(FunctionDefTarget: ast.FunctionDef, stateJob, allImports: UniversalImportTracker) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def writeJobNumba(mapShape: Sequence[int], algorithmSource: ModuleType, callableTarget: str | None = None, parametersNumba: ParametersNumba | None = None, pathFilenameWriteJob: str | PathLike[str] | None = None, unrollCountGaps: bool | None = False, Z0Z_totalEstimated: int = 0, **keywordArguments: Any | None) -> Path: ...
