import ast
from _typeshed import Incomplete
from collections.abc import Callable as Callable, Sequence
from pathlib import Path
from typing import Any, NamedTuple, TypeAlias

ast_Identifier: TypeAlias

class YouOughtaKnow(NamedTuple):
    callableSynthesized: str
    pathFilenameForMe: Path
    astForCompetentProgrammers: ast.ImportFrom

class ifThis:
    @staticmethod
    def nameIs(allegedly: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def subscriptNameIs(allegedly: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def NameReallyIs(allegedly: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def CallAsNameIs(callableName: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def CallAsModuleAttributeIs(moduleName: str, callableName: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def CallReallyIs(moduleName: str, callableName: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def CallDoesNotCallItself(moduleName: str, callableName: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def RecklessCallAsAttributeIs(callableName: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def RecklessCallReallyIs(callableName: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def AssignTo(identifier: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def AnnAssignTo(identifier: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def AugAssignTo(identifier: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def anyAssignmentTo(identifier: str) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def anyOf(*predicates: Callable[[ast.AST], bool]) -> Callable[[ast.AST], bool]: ...
    @staticmethod
    def isUnpackingAnArray(identifier: str) -> Callable[[ast.AST], bool]: ...

class Then:
    @staticmethod
    def copy_astCallKeywords(astCall: ast.Call) -> dict[str, Any]: ...
    @staticmethod
    def make_astCall(caller: ast.Name | ast.Attribute, args: Sequence[ast.expr] | None = None, list_astKeywords: Sequence[ast.keyword] | None = None, dictionaryKeywords: dict[str, Any] | None = None) -> ast.Call: ...
    @staticmethod
    def makeName(identifier: ast_Identifier) -> ast.Name: ...
    @staticmethod
    def addDOTname(nameChain: ast.Name | ast.Attribute, dotName: str) -> ast.Attribute: ...
    @staticmethod
    def makeNameDOTname(identifier: ast_Identifier, *dotName: str) -> ast.Name | ast.Attribute: ...
    @staticmethod
    def appendThis(astStatement: ast.AST) -> Callable[[ast.AST], Sequence[ast.stmt]]: ...
    @staticmethod
    def replaceWith(astStatement: ast.AST) -> Callable[[ast.AST], ast.stmt]: ...
    @staticmethod
    def removeThis(astNode: ast.AST) -> None: ...

class NodeReplacer(ast.NodeTransformer):
    findMe: Callable[[ast.AST], bool]
    doThis: Callable[[ast.AST], ast.AST | Sequence[ast.AST] | None]
    def __init__(self, findMe: Callable[[ast.AST], bool], doThis: Callable[[ast.AST], ast.AST | Sequence[ast.AST] | None]) -> None: ...
    def visit(self, node: ast.AST) -> ast.AST | Sequence[ast.AST] | None: ...

class UniversalImportTracker:
    dictionaryImportFrom: dict[str, set[tuple[str, str | None]]]
    setImport: set[str]
    def __init__(self, startWith: ast.AST | None = None) -> None: ...
    def addAst(self, astImport_: ast.Import | ast.ImportFrom) -> None: ...
    def addImportStr(self, module: str) -> None: ...
    def addImportFromStr(self, module: str, name: str, asname: str | None = None) -> None: ...
    def makeListAst(self) -> list[ast.ImportFrom | ast.Import]: ...
    def update(self, *fromTracker: UniversalImportTracker) -> None: ...
    def walkThis(self, walkThis: ast.AST) -> None: ...

class FunctionInliner(ast.NodeTransformer):
    dictionaryFunctions: dict[str, ast.FunctionDef]
    def __init__(self, dictionaryFunctions: dict[str, ast.FunctionDef]) -> None: ...
    def inlineFunctionBody(self, callableTargetName: str) -> ast.FunctionDef: ...
    def visit_Call(self, node: ast.Call) -> Any | ast.Constant | ast.Call | ast.AST: ...
    def visit_Expr(self, node: ast.Expr) -> ast.AST | list[ast.AST]: ...

class UnpackArrays(ast.NodeTransformer):
    enumIndexClass: Incomplete
    arrayName: Incomplete
    substitutions: dict[str, Any]
    def __init__(self, enumIndexClass, arrayName: str) -> None: ...
    def extract_member_name(self, node: ast.AST) -> str | None: ...
    def transform_slice_element(self, node: ast.AST) -> ast.AST: ...
    def visit_Subscript(self, node: ast.Subscript) -> ast.AST: ...
    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef: ...
