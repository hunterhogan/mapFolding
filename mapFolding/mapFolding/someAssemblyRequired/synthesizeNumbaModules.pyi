from mapFolding.someAssemblyRequired.synthesizeNumbaReusable import *
import ast
import types
from mapFolding import FREAKOUT as FREAKOUT, formatFilenameModule as formatFilenameModule, getAlgorithmDispatcher as getAlgorithmDispatcher, getAlgorithmSource as getAlgorithmSource, getPathPackageINSTALLING as getPathPackageINSTALLING, getPathSyntheticModules as getPathSyntheticModules, indexMy as indexMy, indexTrack as indexTrack, parametersNumbaSuperJit as parametersNumbaSuperJit, parametersNumbaSuperJitParallel as parametersNumbaSuperJitParallel
from pathlib import Path
from typing import Any

def makeFunctionDef(astModule: ast.Module, callableTarget: str, parametersNumba: ParametersNumba | None = None, inlineCallables: bool | None = False, unpackArrays: bool | None = False, allImports: UniversalImportTracker | None = None) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def getFunctionDef(algorithmSource: types.ModuleType, *arguments: Any, **keywordArguments: Any) -> tuple[ast.FunctionDef, UniversalImportTracker]: ...
def makePythonSource(listFunctionDefs: list[ast.FunctionDef], listAstImports: list[ast.Import | ast.ImportFrom], additional_imports: list[str]) -> str: ...
def writePythonAsModule(pythonSource: str, listCallableSynthesized: list[str], relativePathWrite: Path | None, filenameWrite: str | None, formatFilenameWrite: str | None) -> list[YouOughtaKnow]: ...
def makeFlowNumbaOptimized(listCallablesInline: list[str], callableDispatcher: bool | None = False, algorithmSource: types.ModuleType | None = None, relativePathWrite: Path | None = None, filenameModuleWrite: str | None = None, formatFilenameWrite: str | None = None) -> list[YouOughtaKnow]: ...
