import dataclasses
import os
from collections.abc import Sequence
from mapFolding import computationState as computationState, concurrencyPackage as concurrencyPackage, getDatatypeModule as getDatatypeModule, getPathJobRootDEFAULT as getPathJobRootDEFAULT, hackSSOTdatatype as hackSSOTdatatype, hackSSOTdtype as hackSSOTdtype, indexMy as indexMy, indexTrack as indexTrack, setDatatypeLeavesTotal as setDatatypeLeavesTotal
from mapFolding.theSSOT import Array1DElephino as Array1DElephino, Array1DFoldsTotal as Array1DFoldsTotal, Array1DLeavesTotal as Array1DLeavesTotal, Array3D as Array3D, DatatypeElephino as DatatypeElephino, DatatypeFoldsTotal as DatatypeFoldsTotal, DatatypeLeavesTotal as DatatypeLeavesTotal, numpyElephino as numpyElephino, numpyFoldsTotal as numpyFoldsTotal, numpyLeavesTotal as numpyLeavesTotal
from numpy import dtype, integer, ndarray
from numpy.typing import DTypeLike as DTypeLike, NDArray as NDArray
from pathlib import Path
from typing import Any

def validateListDimensions(listDimensions: Sequence[int]) -> tuple[int, ...]: ...
def getLeavesTotal(mapShape: tuple[int, ...]) -> int: ...
def makeConnectionGraph(mapShape: tuple[int, ...], leavesTotal: int, datatype: DTypeLike | None = None): ...
def makeDataContainer(shape: int | tuple[int, ...], datatype: DTypeLike | None = None): ...
def setCPUlimit(CPUlimit: Any | None) -> int: ...
def getTaskDivisions(computationDivisions: int | str | None, concurrencyLimit: int, leavesTotal: int) -> int: ...

@dataclasses.dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)
class ComputationState:
    mapShape: tuple[DatatypeLeavesTotal, ...]
    leavesTotal: DatatypeLeavesTotal
    taskDivisions: DatatypeLeavesTotal
    connectionGraph: Array3D = dataclasses.field(init=False)
    countDimensionsGapped: Array1DLeavesTotal = dataclasses.field(init=False)
    dimensionsTotal: DatatypeLeavesTotal = dataclasses.field(init=False)
    dimensionsUnconstrained: DatatypeLeavesTotal = dataclasses.field(init=False)
    foldGroups: Array1DFoldsTotal = dataclasses.field(init=False)
    foldsTotal: DatatypeFoldsTotal = ...
    gap1ndex: DatatypeLeavesTotal = ...
    gap1ndexCeiling: DatatypeElephino = ...
    gapRangeStart: Array1DElephino = dataclasses.field(init=False)
    gapsWhere: Array1DLeavesTotal = dataclasses.field(init=False)
    groupsOfFolds: DatatypeFoldsTotal = ...
    indexDimension: DatatypeLeavesTotal = ...
    indexLeaf: DatatypeLeavesTotal = ...
    indexMiniGap: DatatypeElephino = ...
    leaf1ndex: DatatypeElephino = ...
    leafAbove: Array1DLeavesTotal = dataclasses.field(init=False)
    leafBelow: Array1DLeavesTotal = dataclasses.field(init=False)
    leafConnectee: DatatypeElephino = ...
    taskIndex: DatatypeLeavesTotal = ...
    def __post_init__(self) -> None: ...
    def getFoldsTotal(self) -> None: ...

def outfitCountFolds(mapShape: tuple[int, ...], computationDivisions: int | str | None = None, concurrencyLimit: int = 1) -> ComputationState: ...
def saveFoldsTotal(pathFilename: str | os.PathLike[str], foldsTotal: int) -> None: ...
def getFilenameFoldsTotal(mapShape: Sequence[int] | ndarray[tuple[int], dtype[integer[Any]]]) -> str: ...
def getPathFilenameFoldsTotal(mapShape: Sequence[int] | ndarray[tuple[int], dtype[integer[Any]]], pathLikeWriteFoldsTotal: str | os.PathLike[str] | None = None) -> Path: ...
