from mapFolding import ComputationState as ComputationState
from numba import prange as prange
from numpy import dtype as dtype, integer as integer, ndarray as ndarray

def activeLeafConnectedToItself(state: ComputationState): ...
def activeLeafGreaterThan0(state: ComputationState): ...
def activeLeafGreaterThanLeavesTotal(state: ComputationState): ...
def activeLeafIsTheFirstLeaf(state: ComputationState): ...
def allDimensionsAreUnconstrained(state: ComputationState): ...
def backtrack(state: ComputationState): ...
def countGaps(state: ComputationState): ...
def decrementDimensionsUnconstrained(state: ComputationState): ...
def dimensionsUnconstrainedCondition(state: ComputationState): ...
def filterCommonGaps(state: ComputationState): ...
def incrementActiveGap(state: ComputationState): ...
def incrementGap1ndexCeiling(state: ComputationState): ...
def incrementIndexDimension(state: ComputationState): ...
def incrementIndexMiniGap(state: ComputationState): ...
def initializeIndexMiniGap(state: ComputationState): ...
def initializeLeafConnectee(state: ComputationState): ...
def initializeVariablesToFindGaps(state: ComputationState): ...
def insertUnconstrainedLeaf(state: ComputationState): ...
def leafBelowSentinelIs1(state: ComputationState): ...
def loopingLeavesConnectedToActiveLeaf(state: ComputationState): ...
def loopingToActiveGapCeiling(state: ComputationState): ...
def loopUpToDimensionsTotal(state: ComputationState): ...
def noGapsHere(state: ComputationState): ...
def placeLeaf(state: ComputationState): ...
def thereIsAnActiveLeaf(state: ComputationState): ...
def thisIsMyTaskIndex(state: ComputationState): ...
def updateLeafConnectee(state: ComputationState): ...
def countInitialize(computationStateInitialized: ComputationState) -> ComputationState: ...
def countParallel() -> None: ...
def countSequential(state: ComputationState): ...
def doTheNeedful(computationStateInitialized: ComputationState): ...
