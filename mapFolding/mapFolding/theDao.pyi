from mapFolding import indexMy as indexMy, indexTrack as indexTrack
from numpy import dtype, integer, ndarray
from typing import Any

def activeLeafConnectedToItself(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def activeLeafGreaterThan0(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def activeLeafGreaterThanLeavesTotal(foldGroups: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def activeLeafIsTheFirstLeaf(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def allDimensionsAreUnconstrained(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def backtrack(my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def countGaps(gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def decrementDimensionsUnconstrained(my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def dimensionsUnconstrainedCondition(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def filterCommonGaps(gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def incrementActiveGap(my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def incrementGap1ndexCeiling(my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def incrementIndexDimension(my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def incrementIndexMiniGap(my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def initializeIndexMiniGap(my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def initializeLeafConnectee(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def initializeVariablesToFindGaps(my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def insertUnconstrainedLeaf(gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]]) -> None: ...
def leafBelowSentinelIs1(track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> Any: ...
def loopingLeavesConnectedToActiveLeaf(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def loopingToActiveGapCeiling(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def loopUpToDimensionsTotal(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def noGapsHere(my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> Any: ...
def placeLeaf(gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def thereIsAnActiveLeaf(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def thisIsMyTaskIndex(my: ndarray[tuple[int], dtype[integer[Any]]]) -> Any: ...
def updateLeafConnectee(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def countInitialize(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def countParallel(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], foldGroups: ndarray[tuple[int], dtype[integer[Any]]], gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def countSequential(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], foldGroups: ndarray[tuple[int], dtype[integer[Any]]], gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
def doTheNeedful(connectionGraph: ndarray[tuple[int, int, int], dtype[integer[Any]]], foldGroups: ndarray[tuple[int], dtype[integer[Any]]], gapsWhere: ndarray[tuple[int], dtype[integer[Any]]], mapShape: ndarray[tuple[int], dtype[integer[Any]]], my: ndarray[tuple[int], dtype[integer[Any]]], track: ndarray[tuple[int, int], dtype[integer[Any]]]) -> None: ...
