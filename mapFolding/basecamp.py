"""You can use this module to access the central dispatch functions for all map-folding computations.

This module provides the primary entry points for computing distinct foldings of multidimensional
maps and related OEIS [1] sequences. The module serves as a routing layer that selects and invokes
specialized algorithm implementations based on problem characteristics and user preferences.

The module name 'basecamp' reflects the concept that this module serves as the starting point from
which you can reach any algorithm implementation, analogous to a basecamp from which mountaineers
access any summit route.

Contents
--------
Functions
	countFolds
		You can count distinct foldings of a multidimensional map.
	NOTcountingFolds
		You can compute OEIS sequences related to meanders [2], symmetric foldings, and formula-based sequences.

Design Goals
------------
Algorithm Version Selection
	This module provides access to any algorithm version. The `countFolds` function is the stable
	interface for multidimensional map folding, including synthetic modules generated by the code generation
	toolchain. The `NOTcountingFolds` function serves as a catch-all for OEIS sequences that use
	specialized algorithms (meanders, symmetric foldings) or closed-form formulas. Future development
	will add `eliminateFolds` as a stable interface for the experimental elimination-based algorithms.

Minimal Preprocessing
	This module quickly routes to the algorithm or algorithm dispatcher (typically named `doTheNeedful`).
	Preparatory work happens in the downstream algorithm modules, not in this basecamp module.

OEIS Identifier Usability
	OEIS identifiers are meaningless labels without context. The module's data structures (via
	`mapFolding.dictionaryOEISMapFolding` [3] and `mapFolding.dictionaryOEIS` [3]) provide
	sequence descriptions alongside identifiers so users can work with domain concepts rather than
	memorizing arbitrary codes. That said, current evidence suggests the package has only one user (the author).

References
----------
[1] OEIS - The On-Line Encyclopedia of Integer Sequences
	https://oeis.org/
[2] Meanders - Wikipedia
	https://en.wikipedia.org/wiki/Meander_(mathematics)
[3] mapFolding.oeis
	Internal package reference (metadata for OEIS sequences)

"""
from collections.abc import Sequence
from mapFolding import (
	getPathFilenameFoldsTotal, getPathRootJobDEFAULT, packageSettings, saveFoldsTotal, saveFoldsTotalFAILearly,
	validateListDimensions)
from os import PathLike
from pathlib import Path, PurePath
from typing import Literal

# ruff: noqa: PLC0415

def countFolds(listDimensions: Sequence[int] | None = None
				, pathLikeWriteFoldsTotal: PathLike[str] | PurePath | None = None
				, computationDivisions: int | str | None = None
				# , * # TODO improve `standardizedEqualToCallableReturn` so it will work with keyword arguments
				, CPUlimit: bool | float | int | None = None  # noqa: FBT001
				, mapShape: tuple[int, ...] | None = None
				, flow: str | None = None
				) -> int:
	"""
	Count the number of distinct ways to fold a map.

	Mathematicians also describe this as folding a strip of stamps, and they usually call the total "number of distinct ways to
	fold" a map the map's "foldings."

	Parameters
	----------
	listDimensions : Sequence[int] | None = None
		List of integers representing the dimensions of the map to be folded.
	pathLikeWriteFoldsTotal : PathLike[str] | PurePath | None = None
		A filename, a path of only directories, or a path with directories and a filename to which `countFolds` will write the
		value of `foldsTotal`. If `pathLikeWriteFoldsTotal` is a path of only directories, `countFolds` creates a filename based
		on the map dimensions.
	computationDivisions : int | str | None = None
		Whether and how to divide the computational work.
		- `None`: no division of the computation into tasks.
		- `int`: into how many tasks `countFolds` will divide the computation. The values 0 or 1 are identical to `None`. It is
		mathematically impossible to divide the computation into more tasks than the map's total leaves.
		- 'maximum': divides the computation into `leavesTotal`-many tasks.
		- 'cpu': divides the computation into the number of available CPUs.
	CPUlimit : bool | float | int | None = None
		If relevant, whether and how to limit the number of processors `countFolds` will use.
		- `False`, `None`, or `0`: No limits on processor usage; uses all available processors. All other values will
		potentially limit processor usage.
		- `True`: Yes, limit the processor usage; limits to 1 processor.
		- `int >= 1`: The maximum number of available processors to use.
		- `0 < float < 1`: The maximum number of processors to use expressed as a fraction of available processors.
		- `-1 < float < 0`: The number of processors to *not* use expressed as a fraction of available processors.
		- `int <= -1`: The number of available processors to *not* use.
		- If the value of `CPUlimit` is a `float` greater than 1 or less than -1, `countFolds` truncates the value to an `int`
		with the same sign as the `float`.
	mapShape : tuple[int, ...] | None = None
		Tuple of integers representing the dimensions of the map to be folded. Mathematicians almost always use the term
		"dimensions", such as in the seminal paper, "Multi-dimensional map-folding". Nevertheless, in contemporary Python
		programming, in the context of these algorithms, the term "shape" makes it much easier to align the mathematics with the
		syntax of the programming language.
	flow : str | None = None
		My stupid way of selecting the version of the algorithm to use in the computation. There are certainly better ways to do
		this, but I have not yet solved this issue. As of 2025 Aug 14, these values will work:
		- 'daoOfMapFolding'
		- 'numba'
		- 'theorem2'
		- 'theorem2Numba'
		- 'theorem2Trimmed'

	Returns
	-------
	foldsTotal : int
		Number of distinct ways to fold a map of the given dimensions.

	Note well
	---------
	You probably do not want to divide your computation into tasks.

	If you want to compute a large `foldsTotal`, dividing the computation into tasks is usually a bad idea. Dividing the
	algorithm into tasks is inherently inefficient: efficient division into tasks means there would be no overlap in the
	work performed by each task. When dividing this algorithm, the amount of overlap is between 50% and 90% by all
	tasks: at least 50% of the work done by every task must be done by each task. If you improve the computation time,
	it will only change by -10 to -50% depending on (at the very least) the ratio of the map dimensions and the number
	of leaves. If an undivided computation would take 10 hours on your computer, for example, the computation will still
	take at least 5 hours but you might reduce the time to 9 hours. Most of the time, however, you will increase the
	computation time. If logicalCores >= `leavesTotal`, it will probably be faster. If logicalCores <= 2 * `leavesTotal`, it
	will almost certainly be slower for all map dimensions.
	"""
#-------- mapShape ---------------------------------------------------------------------

	if mapShape:
		pass
	elif listDimensions:
		mapShape = validateListDimensions(listDimensions)

	if mapShape is None:
		message = (f"""I received these values:
	`{listDimensions = }` and `{mapShape = }`,
	but I was unable to select a map for which to count the folds."""
		)
		raise ValueError(message)

#-------- task division instructions -----------------------------------------------------

	if computationDivisions:
		from mapFolding.beDRY import defineProcessorLimit, getLeavesTotal, getTaskDivisions
		concurrencyLimit: int = defineProcessorLimit(CPUlimit, packageSettings.concurrencyPackage)
		leavesTotal: int = getLeavesTotal(mapShape)
		taskDivisions: int = getTaskDivisions(computationDivisions, concurrencyLimit, leavesTotal)
		del leavesTotal
	else:
		concurrencyLimit = 1
		taskDivisions = 0

#-------- memorialization instructions ---------------------------------------------

	if pathLikeWriteFoldsTotal is not None:
		pathFilenameFoldsTotal: Path | None = getPathFilenameFoldsTotal(mapShape, pathLikeWriteFoldsTotal)
		saveFoldsTotalFAILearly(pathFilenameFoldsTotal)
	else:
		pathFilenameFoldsTotal = None

#-------- Algorithm version -----------------------------------------------------
	if taskDivisions > 1:
		from mapFolding.dataBaskets import ParallelMapFoldingState
		from mapFolding.syntheticModules.countParallelNumba import doTheNeedful

		mapFoldingParallelState: ParallelMapFoldingState = ParallelMapFoldingState(mapShape, taskDivisions=taskDivisions)

		# NOTE `listStatesParallel` exists so you can research the parallel computation.
		foldsTotal, _listStatesParallel = doTheNeedful(mapFoldingParallelState, concurrencyLimit)

# ruff: noqa: E701
	else:
		if all(dimension <= 2 for dimension in mapShape):
			from mapFolding.algorithms.daoOfMapFolding import doTheNeedful
		else:
			match flow:
				case 'numba': from mapFolding.syntheticModules.daoOfMapFoldingNumba import doTheNeedful
				case 'theorem2': from mapFolding.syntheticModules.theorem2 import doTheNeedful
				case 'theorem2Numba': from mapFolding.syntheticModules.theorem2Numba import doTheNeedful
				case 'theorem2Trimmed': from mapFolding.syntheticModules.theorem2Trimmed import doTheNeedful
				case 'daoOfMapFolding' | _: from mapFolding.algorithms.daoOfMapFolding import doTheNeedful

		from mapFolding.dataBaskets import MapFoldingState
		mapFoldingState: MapFoldingState = MapFoldingState(mapShape)
		mapFoldingState = doTheNeedful(mapFoldingState)
		foldsTotal = mapFoldingState.foldsTotal

#-------- Follow memorialization instructions ---------------------------------------------

	if pathFilenameFoldsTotal is not None:
		saveFoldsTotal(pathFilenameFoldsTotal, foldsTotal)

	return foldsTotal

# TODO `NOTcountingFolds`: improve identifier.
def NOTcountingFolds(oeisID: str, oeis_n: int, flow: str | None = None
		, pathLikeWriteFoldsTotal: PathLike[str] | PurePath | None = None
		, CPUlimit: bool | float | int | None = None  # noqa: FBT001
		) -> int:
	"""You can compute the n-th term of specified OEIS sequences using specialized algorithms.

	(AI generated docstring)

	This function computes values for OEIS [1] sequences that require specialized algorithms
	(meanders [2], symmetric foldings) or closed-form formulas, as opposed to the general
	multidimensional map-folding algorithm accessible via `countFolds` [3]. The function
	dispatches to algorithm-specific implementations based on `oeisID` and `flow` parameters.

	The function name reflects that these computations are NOT standard map-folding counts:
	meanders use transfer matrix methods, symmetric foldings exploit symmetry constraints,
	and formula-based sequences compute directly without search.

	Parameters
	----------
	oeisID : str
		OEIS sequence identifier. Supported sequences fall into three categories:
		- Formula-based: A000136, A000560, A001010, A001011, A005315, A060206, A077460,
			A078591, A086345 [4], A178961, A223094, A259702, A301620
		- Meanders: A000682 [5], A005316 [6]
		- Symmetric foldings: A007822
	oeis_n : int
		Sequence index (typically starting from 0 or 1, depending on OEIS sequence offset).
	flow : str | None = None
		Algorithm variant selector. Available values depend on `oeisID`:
		- For A000682, A005316: 'matrixMeanders' (default), 'matrixNumPy', 'matrixPandas'
		- For A007822: 'algorithm' (default), 'asynchronous', 'theorem2', 'theorem2Numba', 'theorem2Trimmed'
		- For formula-based sequences: ignored (`flow` has no effect)
	CPUlimit : bool | float | int | None = None
		Processor usage limit for parallel algorithms (A007822 with certain `flow` values).
		Interpretation matches `countFolds.CPUlimit` [3]:
		- `False`, `None`, or `0`: use all available processors
		- `True`: limit to 1 processor
		- `int >= 1`: maximum number of processors
		- `0 < float < 1`: fraction of available processors
		- `-1 < float < 0`: fraction of processors to *not* use
		- `int <= -1`: number of processors to *not* use

	Returns
	-------
	countTotal : int
		The n-th term of the specified OEIS sequence.

	Raises
	------
	ValueError
		If `oeisID` matches A000682 or A005316 but receives an invalid internal state (programming error, not user error).

	Examples
	--------
	Formula-based sequence:

	>>> from mapFolding.basecamp import NOTcountingFolds
	>>> NOTcountingFolds('A000136', 3)
	8

	Meander computation with matrix algorithm:

	>>> NOTcountingFolds('A000682', 5, flow='matrixMeanders')
	42

	Symmetric folding with Numba-optimized implementation:

	>>> NOTcountingFolds('A007822', 6, flow='theorem2Numba')
	144

	See Also
	--------
	mapFolding.basecamp.countFolds
		General multidimensional map-folding computation.
	mapFolding.oeis.oeisIDfor_n
		Convenience function that routes to either `countFolds` or `NOTcountingFolds` based on `oeisID`.

	Algorithm Details
	-----------------
	Meander Sequences (A000682, A005316)
		Meanders [2] represent configurations of non-intersecting curves crossing a line. The
		algorithms use transfer matrix methods to enumerate valid configurations. Initial arc codes
		(binary representations of curve crossings) are constructed based on sequence parity, then
		iterative transformations generate all valid meander states. See
		`mapFolding.reference.A000682facts` [7] and `mapFolding.reference.A005316facts` [8] for
		sequence-specific parameters.

	Symmetric Folding Sequence (A007822)
		A007822 counts foldings of 1Ã—(2n) maps that are symmetric under 180-degree rotation.
		The algorithm exploits symmetry to reduce the search space. The `flow` parameter selects
		between serial, parallel (asynchronous), and optimized implementations (theorem2 variants).

	Formula-Based Sequences
		These sequences have closed-form definitions that compute values directly without search.
		Implementations reside in `mapFolding.algorithms.oeisIDbyFormula` [9]. Some formulas
		(A259702, A301620) are defined recursively in terms of A000682.

	References
	----------
	[1] OEIS - The On-Line Encyclopedia of Integer Sequences
		https://oeis.org/
	[2] Meanders - Wikipedia
		https://en.wikipedia.org/wiki/Meander_(mathematics)
	[3] mapFolding.basecamp.countFolds
		Internal package reference
	[4] mapFolding.algorithms.A086345
		Internal package reference (special formula implementation for A086345)
	[5] OEIS A000682 - Semi-meanders: number of Folded meanders
		https://oeis.org/A000682
	[6] OEIS A005316 - Meanders
		https://oeis.org/A005316
	[7] mapFolding.reference.A000682facts
		Internal package reference (arc code patterns and bit-width data)
	[8] mapFolding.reference.A005316facts
		Internal package reference (boundary bucket distributions)
	[9] mapFolding.algorithms.oeisIDbyFormula
		Internal package reference (closed-form sequence formulas)

	"""  # noqa: RUF002
#-------- memorialization instructions ---------------------------------------------

	if pathLikeWriteFoldsTotal is not None:
		# For sequences without a natural mapShape, create filename based on oeisID and oeis_n
		if oeisID == 'A007822':
			# A007822 has a mapShape, so use the standard approach
			mapShapeForFilename: tuple[int, ...] = (1, 2 * oeis_n)
			pathFilenameFoldsTotal: Path | None = getPathFilenameFoldsTotal(mapShapeForFilename, pathLikeWriteFoldsTotal)
		else:
			# Other sequences don't have mapShape, so create filename directly
			filenameCountTotal: str = f"{oeisID}_n{oeis_n}.countTotal"
			pathLikeSherpa = Path(pathLikeWriteFoldsTotal)
			if pathLikeSherpa.is_dir():
				pathFilenameFoldsTotal = pathLikeSherpa / filenameCountTotal
			elif pathLikeSherpa.is_file() and pathLikeSherpa.is_absolute():
				pathFilenameFoldsTotal = pathLikeSherpa
			else:
				pathFilenameFoldsTotal = getPathRootJobDEFAULT() / pathLikeSherpa
			pathFilenameFoldsTotal.parent.mkdir(parents=True, exist_ok=True)
		saveFoldsTotalFAILearly(pathFilenameFoldsTotal)
	else:
		pathFilenameFoldsTotal = None

#-------- Algorithm selection and execution ---------------------------------------------

	countTotal: int = -31212012 # ERROR
	matched_oeisID: bool = True

	match oeisID:
		case 'A000136': from mapFolding.algorithms.oeisIDbyFormula import A000136 as doTheNeedful
		case 'A000560': from mapFolding.algorithms.oeisIDbyFormula import A000560 as doTheNeedful
		case 'A001010': from mapFolding.algorithms.oeisIDbyFormula import A001010 as doTheNeedful
		case 'A001011': from mapFolding.algorithms.oeisIDbyFormula import A001011 as doTheNeedful
		case 'A005315': from mapFolding.algorithms.oeisIDbyFormula import A005315 as doTheNeedful
		case 'A060206': from mapFolding.algorithms.oeisIDbyFormula import A060206 as doTheNeedful
		case 'A077460': from mapFolding.algorithms.oeisIDbyFormula import A077460 as doTheNeedful
		case 'A078591': from mapFolding.algorithms.oeisIDbyFormula import A078591 as doTheNeedful
		case 'A086345': from mapFolding.algorithms.A086345 import A086345 as doTheNeedful
		case 'A178961': from mapFolding.algorithms.oeisIDbyFormula import A178961 as doTheNeedful
		case 'A223094': from mapFolding.algorithms.oeisIDbyFormula import A223094 as doTheNeedful
		case 'A259702': from mapFolding.algorithms.oeisIDbyFormula import A259702 as doTheNeedful
		case 'A301620': from mapFolding.algorithms.oeisIDbyFormula import A301620 as doTheNeedful
		case _: matched_oeisID = False
	if matched_oeisID:
		countTotal = doTheNeedful(oeis_n) # pyright: ignore[reportPossiblyUnboundVariable]
	else:
		matched_oeisID = True
		match oeisID:
			case 'A000682' | 'A005316':
				match flow:
					case 'matrixNumPy':
						from mapFolding.algorithms.matrixMeandersNumPyndas import doTheNeedful, MatrixMeandersNumPyState as State
					case 'matrixPandas':
						from mapFolding.algorithms.matrixMeandersNumPyndas import (
							doTheNeedfulPandas as doTheNeedful, MatrixMeandersNumPyState as State)
					case 'matrixMeanders' | _:
						from mapFolding.algorithms.matrixMeanders import doTheNeedful
						from mapFolding.dataBaskets import MatrixMeandersState as State

				boundary: int = oeis_n - 1

				if oeisID == 'A000682':
					if oeis_n == 1:
						return 1
					elif oeis_n & 0b1:
						arcCode: int = 0b101
					else:
						arcCode = 0b1
					listArcCodes: list[int] = [(arcCode << 1) | arcCode]
													#  0b1010 | 0b0101 is 0b1111, or 0xf
													#    0b10 |   0b01 is   0b11, or 0x3

					MAXIMUMarcCode: int = 1 << (2 * boundary + 4)
					while listArcCodes[-1] < MAXIMUMarcCode:
						arcCode = (arcCode << 4) | 0b0101 # e.g., 0b 10000 | 0b 0101 = 0b 10101
						listArcCodes.append((arcCode << 1) | arcCode) # e.g., 0b 101010 | 0b 1010101 = 0b 111111 = 0x3f
						# Thereafter, append 0b1111 or 0xf, so, e.g., 0x3f, 0x3ff, 0x3fff, 0x3ffff, ...
						# See "mapFolding/reference/A000682facts.py"
					dictionaryMeanders=dict.fromkeys(listArcCodes, 1)

				elif oeisID == 'A005316':
					if oeis_n & 0b1:
						dictionaryMeanders: dict[int, int] = {0b1111: 1} # 0xf
					else:
						dictionaryMeanders = {0b10110: 1}
				else:
					message = f"Programming error: I should never have received `{oeisID = }`."
					raise ValueError(message)

				state = State(oeis_n, oeisID, boundary, dictionaryMeanders)
				countTotal = doTheNeedful(state) # pyright: ignore[reportArgumentType]  # ty:ignore[invalid-argument-type]
			case 'A007822':
				mapShape: tuple[Literal[1], int] = (1, 2 * oeis_n)
				from mapFolding import defineProcessorLimit
				concurrencyLimit: int = defineProcessorLimit(CPUlimit)

				from mapFolding.dataBaskets import SymmetricFoldsState
				symmetricState: SymmetricFoldsState = SymmetricFoldsState(mapShape)

				match flow:
					case 'asynchronous':
						from mapFolding.syntheticModules.A007822.asynchronous import doTheNeedful
						symmetricState = doTheNeedful(symmetricState, concurrencyLimit)
					case 'theorem2':
						from mapFolding.syntheticModules.A007822.theorem2 import doTheNeedful
						symmetricState = doTheNeedful(symmetricState)
					case 'theorem2Numba':
						from mapFolding.syntheticModules.A007822.theorem2Numba import doTheNeedful
						symmetricState = doTheNeedful(symmetricState)
					case 'theorem2Trimmed':
						from mapFolding.syntheticModules.A007822.theorem2Trimmed import doTheNeedful
						symmetricState = doTheNeedful(symmetricState)
					case _:
						from mapFolding.syntheticModules.A007822.algorithm import doTheNeedful
						symmetricState = doTheNeedful(symmetricState)

				countTotal = symmetricState.symmetricFolds
			case _:
				matched_oeisID = False

#-------- Follow memorialization instructions ---------------------------------------------

	if pathFilenameFoldsTotal is not None:
		saveFoldsTotal(pathFilenameFoldsTotal, countTotal)

	return countTotal
