"""You can use this module to access the central dispatch functions for all map-folding computations.

This module provides the primary entry points for computing distinct foldings of multidimensional
maps and related OEIS [1] sequences. The module serves as a routing layer that selects and invokes
specialized algorithm implementations based on problem characteristics and user preferences.

The module name 'basecamp' reflects the concept that this module serves as the starting point from
which you can reach any algorithm implementation, analogous to a basecamp from which mountaineers
access any summit route.

Contents
--------
Functions
	countFolds
		You can count distinct foldings of a multidimensional map.
	NOTcountingFolds
		You can compute OEIS sequences related to meanders [2], symmetric foldings, and formula-based sequences.

Design Goals
------------
Algorithm Version Selection
	This module provides access to any algorithm version. The `countFolds` function is the stable
	interface for multidimensional map folding, including synthetic modules generated by the code generation
	toolchain. The `NOTcountingFolds` function serves as a catch-all for OEIS sequences that use
	specialized algorithms (meanders, symmetric foldings) or closed-form formulas. Future development
	will add `eliminateFolds` as a stable interface for the experimental elimination-based algorithms.

Minimal Preprocessing
	This module quickly routes to the algorithm or algorithm dispatcher (typically named `doTheNeedful`).
	Preparatory work happens in the downstream algorithm modules, not in this basecamp module.

OEIS Identifier Usability
	OEIS identifiers are meaningless labels without context. The module's data structures (via
	`mapFolding.dictionaryOEISMapFolding` [3] and `mapFolding.dictionaryOEIS` [3]) provide
	sequence descriptions alongside identifiers so users can work with domain concepts rather than
	memorizing arbitrary codes. That said, current evidence suggests the package has only one user (the author).

References
----------
[1] OEIS - The On-Line Encyclopedia of Integer Sequences
	https://oeis.org/
[2] Meanders - Wikipedia
	https://en.wikipedia.org/wiki/Meander_(mathematics)
[3] mapFolding.oeis
	Internal package reference (metadata for OEIS sequences)

"""
from collections.abc import Sequence
from mapFolding import packageSettings
from mapFolding.beDRY import validateListDimensions
from mapFolding.filesystemToolkit import getPathFilenameFoldsTotal, saveFoldsTotal, saveFoldsTotalFAILearly
from os import PathLike
from pathlib import Path, PurePath

# ruff: noqa: PLC0415

def countFolds(listDimensions: Sequence[int] | None = None
				, pathLikeWriteFoldsTotal: PathLike[str] | PurePath | None = None
				, computationDivisions: int | str | None = None
				# , * # TODO improve `standardizedEqualToCallableReturn` so it will work with keyword arguments
				, CPUlimit: bool | float | int | None = None  # noqa: FBT001
				, mapShape: tuple[int, ...] | None = None
				, flow: str | None = None
				) -> int:
	"""
	Count the number of distinct ways to fold a map.

	Mathematicians also describe this as folding a strip of stamps, and they usually call the total "number of distinct ways to
	fold" a map the map's "foldings."

	Parameters
	----------
	listDimensions : Sequence[int] | None = None
		List of integers representing the dimensions of the map to be folded.
	pathLikeWriteFoldsTotal : PathLike[str] | PurePath | None = None
		A filename, a path of only directories, or a path with directories and a filename to which `countFolds` will write the
		value of `foldsTotal`. If `pathLikeWriteFoldsTotal` is a path of only directories, `countFolds` creates a filename based
		on the map dimensions.
	computationDivisions : int | str | None = None
		Whether and how to divide the computational work.
		- `None`: no division of the computation into tasks.
		- `int`: into how many tasks `countFolds` will divide the computation. The values 0 or 1 are identical to `None`. It is
		mathematically impossible to divide the computation into more tasks than the map's total leaves.
		- 'maximum': divides the computation into `leavesTotal`-many tasks.
		- 'cpu': divides the computation into the number of available CPUs.
	CPUlimit : bool | float | int | None = None
		If relevant, whether and how to limit the number of processors `countFolds` will use.
		- `False`, `None`, or `0`: No limits on processor usage; uses all available processors. All other values will
		potentially limit processor usage.
		- `True`: Yes, limit the processor usage; limits to 1 processor.
		- `int >= 1`: The maximum number of available processors to use.
		- `0 < float < 1`: The maximum number of processors to use expressed as a fraction of available processors.
		- `-1 < float < 0`: The number of processors to *not* use expressed as a fraction of available processors.
		- `int <= -1`: The number of available processors to *not* use.
		- If the value of `CPUlimit` is a `float` greater than 1 or less than -1, `countFolds` truncates the value to an `int`
		with the same sign as the `float`.
	mapShape : tuple[int, ...] | None = None
		Tuple of integers representing the dimensions of the map to be folded. Mathematicians almost always use the term
		"dimensions", such as in the seminal paper, "Multi-dimensional map-folding". Nevertheless, in contemporary Python
		programming, in the context of these algorithms, the term "shape" makes it much easier to align the mathematics with the
		syntax of the programming language.
	flow : str | None = None
		My stupid way of selecting the version of the algorithm to use in the computation. There are certainly better ways to do
		this, but I have not yet solved this issue. As of 2025 Aug 14, these values will work:
		- 'daoOfMapFolding'
		- 'numba'
		- 'theorem2'
		- 'theorem2Numba'
		- 'theorem2Trimmed'

	Returns
	-------
	foldsTotal : int
		Number of distinct ways to fold a map of the given dimensions.

	Note well
	---------
	You probably do not want to divide your computation into tasks.

	If you want to compute a large `foldsTotal`, dividing the computation into tasks is usually a bad idea. Dividing the
	algorithm into tasks is inherently inefficient: efficient division into tasks means there would be no overlap in the
	work performed by each task. When dividing this algorithm, the amount of overlap is between 50% and 90% by all
	tasks: at least 50% of the work done by every task must be done by each task. If you improve the computation time,
	it will only change by -10 to -50% depending on (at the very least) the ratio of the map dimensions and the number
	of leaves. If an undivided computation would take 10 hours on your computer, for example, the computation will still
	take at least 5 hours but you might reduce the time to 9 hours. Most of the time, however, you will increase the
	computation time. If logicalCores >= `leavesTotal`, it will probably be faster. If logicalCores <= 2 * `leavesTotal`, it
	will almost certainly be slower for all map dimensions.
	"""
#-------- mapShape ---------------------------------------------------------------------

	if mapShape:
		pass
	elif listDimensions:
		mapShape = validateListDimensions(listDimensions)

	if mapShape is None:
		message = (f"""I received these values:
	`{listDimensions = }` and `{mapShape = }`,
	but I was unable to select a map for which to count the folds."""
		)
		raise ValueError(message)

#-------- task division instructions -----------------------------------------------------

	if computationDivisions:
		from mapFolding.beDRY import defineProcessorLimit, getLeavesTotal, getTaskDivisions
		concurrencyLimit: int = defineProcessorLimit(CPUlimit, packageSettings.concurrencyPackage)
		leavesTotal: int = getLeavesTotal(mapShape)
		taskDivisions: int = getTaskDivisions(computationDivisions, concurrencyLimit, leavesTotal)
		del leavesTotal
	else:
		concurrencyLimit = 1
		taskDivisions = 0

#-------- memorialization instructions ---------------------------------------------

	if pathLikeWriteFoldsTotal is not None:
		pathFilenameFoldsTotal: Path | None = getPathFilenameFoldsTotal(mapShape, pathLikeWriteFoldsTotal)
		saveFoldsTotalFAILearly(pathFilenameFoldsTotal)
	else:
		pathFilenameFoldsTotal = None

#-------- Algorithm version -----------------------------------------------------
	if taskDivisions > 1:
		from mapFolding.dataBaskets import ParallelMapFoldingState
		from mapFolding.syntheticModules.countParallelNumba import doTheNeedful

		mapFoldingParallelState: ParallelMapFoldingState = ParallelMapFoldingState(mapShape, taskDivisions=taskDivisions)

		# NOTE `listStatesParallel` exists so you can research the parallel computation.
		foldsTotal, _listStatesParallel = doTheNeedful(mapFoldingParallelState, concurrencyLimit)

# ruff: noqa: E701
	else:
		if all(dimension <= 2 for dimension in mapShape):
			from mapFolding.algorithms.daoOfMapFolding import doTheNeedful
		else:
			match flow:
				case 'numba': from mapFolding.syntheticModules.daoOfMapFoldingNumba import doTheNeedful
				case 'theorem2': from mapFolding.syntheticModules.theorem2 import doTheNeedful
				case 'theorem2Numba': from mapFolding.syntheticModules.theorem2Numba import doTheNeedful
				case 'theorem2Trimmed': from mapFolding.syntheticModules.theorem2Trimmed import doTheNeedful
				case 'daoOfMapFolding' | _: from mapFolding.algorithms.daoOfMapFolding import doTheNeedful

		from mapFolding.dataBaskets import MapFoldingState
		mapFoldingState: MapFoldingState = MapFoldingState(mapShape)
		mapFoldingState = doTheNeedful(mapFoldingState)
		foldsTotal = mapFoldingState.foldsTotal

#-------- Follow memorialization instructions ---------------------------------------------

	if pathFilenameFoldsTotal is not None:
		saveFoldsTotal(pathFilenameFoldsTotal, foldsTotal)

	return foldsTotal

